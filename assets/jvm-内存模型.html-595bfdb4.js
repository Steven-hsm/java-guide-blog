import{_ as l,p as i,q as r,a1 as o}from"./framework-8fa3e4ce.js";const s="/java-guide-blog/assets/jvm内存模型2-463db775.png",t="/java-guide-blog/assets/对象创建过程-c70bf8ff.png",n="/java-guide-blog/assets/对象内存分配-9f499430.png",e="/java-guide-blog/assets/老年代空间担保机制-5a85e66b.png",a={},p=o('<h1 id="jvm-内存模型" tabindex="-1"><a class="header-anchor" href="#jvm-内存模型" aria-hidden="true">#</a> jvm-内存模型</h1><h3 id="_1-内存模型" tabindex="-1"><a class="header-anchor" href="#_1-内存模型" aria-hidden="true">#</a> 1. 内存模型</h3><p><img src="'+s+'" alt="image-20230209212230598"></p><p><strong>JVM内存参数设置</strong></p><ul><li>堆 <ul><li>-Xms 表示java虚拟机堆区内存初始内存分配的大小</li><li>-Xmx 表示java虚拟机堆区内存可被分配的最大上限</li></ul></li><li>新生区 <ul><li>-Xmn 表示java虚拟机年轻代大小</li></ul></li><li>方法区 <ul><li><strong>-XX：MaxMetaspaceSize</strong> 设置元空间的最大值，默认为-1，即不做限制，或者说只受限于本地内存大小</li><li><strong>-XX：MetaspaceSize</strong> 指定元空间触发Fullgc的初始阈值（元空间无固定初始大小），以字节为单位，默认为21M,达到该值就会触发fullgc进行类型卸载，同时收集器也会对该值进行调整。 <ul><li>如果释放了大量空间就适当降低该值</li><li>如果释放了很少的空间，在不超过<code>-XX：MaxMetaspaceSize</code>的情况下，适当提高该值</li></ul></li><li><strong>-XX:PermSize</strong> 是jdk早起版本的参数，表示永久代的初始容量</li><li>由于调整元空间的大小需要Full GC,如果在启动项目时就发生大量的Full GC,通常是由于永久代或元空间发生了大小调整。基于这种情况，一般建议将将MetaspaceSize和MaxMetaspaceSize设置成一样的值</li></ul></li><li>栈 <ul><li>-Xss 设置栈空间的大小</li></ul></li></ul><h3 id="_2-对象的创建" tabindex="-1"><a class="header-anchor" href="#_2-对象的创建" aria-hidden="true">#</a> 2.对象的创建</h3><p><img src="'+t+'" alt="image-20230209212430347"></p><ol><li><p>类加载检查</p><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p></li><li><p>分配内存</p><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p><p>这个步骤有两个问题：</p><ol><li>如何划分内存。</li><li>在并发情况下， 可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况</li></ol><p><strong>划分内存的方法：</strong></p><ul><li>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)</li></ul><p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p><ul><li>“空闲列表”（Free List）</li></ul><p>如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</p><p><strong>解决并发问题的方法：</strong></p><ul><li>CAS（compare and swap）</li></ul><p>虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p><ul><li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</li></ul><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过<strong>­XX:+/­</strong>UseTLAB<strong>参数来设定虚拟机是否使用TLAB(JVM会默认开启</strong>­XX:+<strong>UseTLAB</strong>)，­XX:TLABSize 指定TLAB大小。</p></li><li><p>初始化</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></li><li><p>设置对象头</p><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。</p></li><li><p>执行init方法</p><p>执行init方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p></li></ol><ul><li>什么是java对象的<strong>指针压缩</strong>？</li></ul><ol><li><p>jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩</p></li><li><p>jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针</p></li><li><p>启用指针压缩:­XX:+UseCompressedOops(<strong>默认开启</strong>)，禁止指针压缩:­XX:­UseCompressedOops</p></li></ol><ul><li>为什么要进行指针压缩？</li></ul><ol><li><p>在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，<strong>占用较大宽带，同时<strong><strong>GC</strong></strong>也会承受较大压力</strong></p></li><li><p>为了减少64位平台下内存的消耗，启用指针压缩功能</p></li><li><p>在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</p></li><li><p>堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</p></li><li><p>堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p></li></ol><h3 id="_3-对象内存的分配" tabindex="-1"><a class="header-anchor" href="#_3-对象内存的分配" aria-hidden="true">#</a> 3. 对象内存的分配</h3><p><img src="'+n+'" alt="image-20230209213500552"></p><ul><li><p>对象栈上分配（<strong>栈上分配依赖于逃逸分析和标量替换</strong>）</p><p>jvm通过<strong>对象逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的</p><p>内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><ul><li><strong>逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</li><li>通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过<strong>标量替换</strong>优先分配在栈上(<strong>栈上分配</strong>)，</li><li>**标量替换：**通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，<strong>JVM不会创建该对象</strong>，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配</li><li>**标量与聚合量：**标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。</li></ul></li><li><p><strong>对象在EDEN区分配</strong></p><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。</p><ul><li><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快</li><li><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上</li><li><strong>Eden与Survivor区默认8:1:1</strong></li></ul></li><li><p><strong>大对象直接进入老年代</strong></p><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p><ul><li>原因：避免大对象分配内存时的复制操作而降低效率</li></ul></li><li><p><strong>长期存活的对象将直接进入老年代</strong></p><p>经过一次gc后，还存活的对象，年龄就会加1，超过一定的年龄后就会放入老年代</p></li><li><p><strong>对象动态年龄判断机制</strong></p><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以直接进入老年代了</p><p>例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的。</strong></p></li><li><p><strong>老年代空间分配担保机制</strong></p><p>年轻代每次<strong>minor gc</strong>之前JVM都会计算下老年代<strong>剩余可用空间</strong>如果这个可用空间小于年轻代里现有的所有对象大小之和(<strong>包括垃圾对象</strong></p><p><img src="'+e+'" alt="image-20230209222307687"></p></li></ul><h3 id="_4-对象内存的回收" tabindex="-1"><a class="header-anchor" href="#_4-对象内存的回收" aria-hidden="true">#</a> 4.对象内存的回收</h3><ul><li>引用计数法 <ul><li>无法解决对象直接循环引用的问题</li></ul></li><li>可达性分析法 <ul><li>将**“GC Roots”** 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为<strong>非垃圾对象</strong>，其余未标记的对象都是垃圾对象</li><li><strong>GC Roots</strong>根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</li></ul></li></ul><p><strong>常见引用类型</strong></p><ul><li><strong>强引用</strong>：普通的变量引用</li><li>**软引用：**将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存</strong></li><li><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>GC会直接回收掉</strong>，很少用</li><li>**虚引用：**虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</li></ul><p><strong>finalize()方法最终判定对象是否存活</strong></p><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程</p><p><strong>如何判断一个类是无用的类</strong></p><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul>',25),g=[p];function u(c,d){return i(),r("div",null,g)}const v=l(a,[["render",u],["__file","jvm-内存模型.html.vue"]]);export{v as default};
