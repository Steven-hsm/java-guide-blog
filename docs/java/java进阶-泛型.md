# java进阶-泛型
Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样.

泛型的本质就是为了参数化类型
* 在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。
* 在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法

**作用**
* 适用于多种数据类型执行相同的代码（代码复用）
* 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）

## 泛型类
1. 单元泛型
```java
class Result<T>{
    private T data ;//泛型数据，可以接收不同的类型结果
    private Integer code;
    private String message;
}
```
2. 多元泛型
```java
class MyMap<k,V>{
    private K key;
    private V value;
}
```
## 泛型接口
```java
interface Info<T>{        // 在接口上定义泛型  
    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  
}  
```
## 泛型方法
泛型方法，是在调用方法的时候指明泛型的具体类型
![泛型方法.png](../images/泛型方法.png)
* 第一个<T>声明这是一个泛型方法，且泛型变量只能为T,多个可以写成<T,R>
* 泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活

## 泛型的上下限
为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<? extends A>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数
* 上限
```java
class Info<T extends Number> {    // 此处泛型只能是数字类型
}
```
* 下限
```java
public static void fun(Info<? super String> temp){    // 只能接收String或Object类型的泛型，String类的父类只有Object类
        System.out.print(temp + ", ") ;
    }
```
* 多个限制 &
```java
 public static <T extends Staff & Passenger> void discount(T t){
    }
```

* <?> 无限制通配符
* <? extends E> extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类
* <? super E> super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类

## 深入理解泛型
> Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。

**泛型的类型擦除**原则是：
* 消除类型参数声明，即删除<>及其包围的部分。
* 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。
* 为了保证类型安全，必要时插入强制类型转换代码。
* 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。

**如何擦除**
* 擦除类型参数 - 无限制类型擦除 T -> Object
* 擦除类型参数 - 有限制类型擦除 T extends Number -> Number


参考
[泛型机制详解](https://www.pdai.tech/md/java/basic/java-basic-x-generic.html)

