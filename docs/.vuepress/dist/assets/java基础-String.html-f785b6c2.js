import{_ as n,p as a,q as s,a1 as t}from"./framework-8fa3e4ce.js";const e={},i=t(`<h1 id="java基础-string" tabindex="-1"><a class="header-anchor" href="#java基础-string" aria-hidden="true">#</a> java基础-String</h1><p>String 被声明为 final，因此它不可被继承。内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token doc-comment comment">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="不可变的优势" tabindex="-1"><a class="header-anchor" href="#不可变的优势" aria-hidden="true">#</a> 不可变的优势</h2><ol><li>可以缓存 hash 值 <ul><li>String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算</li></ul></li><li>String缓存池 <ul><li>一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool</li></ul></li><li>安全性得到保障 <ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li></ul></li><li>线程安全、 <ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li></ul></li></ol><h2 id="string-stringbuffer-and-stringbuilder对比" tabindex="-1"><a class="header-anchor" href="#string-stringbuffer-and-stringbuilder对比" aria-hidden="true">#</a> String, StringBuffer and StringBuilder对比</h2><ol><li>可变性 <ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul></li><li>线程安全性 <ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul></li></ol><h2 id="string-intern" tabindex="-1"><a class="header-anchor" href="#string-intern" aria-hidden="true">#</a> String.intern()</h2><p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象</p><h2 id="常量池保存位置" tabindex="-1"><a class="header-anchor" href="#常量池保存位置" aria-hidden="true">#</a> 常量池保存位置</h2><table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table>`,11),r=[i];function l(o,d){return a(),s("div",null,r)}const p=n(e,[["render",l],["__file","java基础-String.html.vue"]]);export{p as default};
