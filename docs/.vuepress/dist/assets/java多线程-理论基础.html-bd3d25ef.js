import{_ as l}from"./重排序说明-f0584ed8.js";import{_ as i,p as a,q as e,a1 as r}from"./framework-8fa3e4ce.js";const t={},h=r('<h1 id="java多线程-理论基础" tabindex="-1"><a class="header-anchor" href="#java多线程-理论基础" aria-hidden="true">#</a> java多线程-理论基础</h1><h2 id="为什么产生多线程" tabindex="-1"><a class="header-anchor" href="#为什么产生多线程" aria-hidden="true">#</a> 为什么产生多线程</h2><p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致 可见性问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致 有序性问题</li></ul><p><strong>结果：</strong> 如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><h2 id="并发问题的根源" tabindex="-1"><a class="header-anchor" href="#并发问题的根源" aria-hidden="true">#</a> 并发问题的根源</h2><ul><li>可见性: CPU缓存引起，一个线程对共享变量的修改，另外一个线程能够立刻看到。</li><li>原子性: 分时复用引起，一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>有序性: 重排序引起，程序执行的顺序按照代码的先后顺序执行 <ul><li>编译器优化的重排序</li><li>指令级并行的重排序</li><li>内存系统的重排序 <img src="'+l+'" alt="重排序.png"></li></ul></li></ul><h2 id="happens-before规则" tabindex="-1"><a class="header-anchor" href="#happens-before规则" aria-hidden="true">#</a> happens-before规则</h2><ol><li>单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。</li><li>管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</li><li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</li><li>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</li><li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。</li><li>线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。</li><li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</li></ol><h2 id="线程安全-不是一个非真即假的命题" tabindex="-1"><a class="header-anchor" href="#线程安全-不是一个非真即假的命题" aria-hidden="true">#</a> 线程安全: 不是一个非真即假的命题</h2><p>一个类在可以被多个线程安全调用时就是线程安全的。 线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><ol><li>不可变 <ul><li>不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。</li></ul></li><li>绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施</li><li>相对线程安全： <ul><li>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li></ul></li><li>线程兼容：线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用</li><li>线程对立：指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</li></ol><h2 id="线程安全的实现方法" tabindex="-1"><a class="header-anchor" href="#线程安全的实现方法" aria-hidden="true">#</a> 线程安全的实现方法</h2><ol><li>互斥同步 synchronized 和 ReentrantLock。 <ul><li>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</li><li>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</li></ul></li><li>非阻塞同步 <ul><li>CAS:CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B</li><li>AtomicInteger:使用了 Unsafe 类的 CAS 操作</li><li>ABA:如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</li></ul></li><li>无同步方案 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 <ul><li>栈封闭:多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</li><li>线程本地存储(ThreadLocal):</li><li>可重入代码：可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</li></ul></li></ol>',14),n=[h];function o(d,s){return a(),e("div",null,n)}const _=i(t,[["render",o],["__file","java多线程-理论基础.html.vue"]]);export{_ as default};
