import{_ as i,p as l,q as a,a1 as e}from"./framework-8fa3e4ce.js";const s="/java-guide-blog/assets/索引-二叉树-8a2be4f4.png",r="/java-guide-blog/assets/索引-红黑树-e8051202.png",h="/java-guide-blog/assets/索引-hash-a0864a53.png",t="/java-guide-blog/assets/索引-B树-fbe027ea.png",n="/java-guide-blog/assets/索引-B_树-6d26e663.png",d="/java-guide-blog/assets/MyISAM-索引存储结构-c7567156.png",_={},o=e('<p><strong>索引的本质：<strong>索引是帮助Mysql高效获取数据的</strong>排好序</strong>的<strong>数据结构</strong></p><h2 id="_1-索引的数据结构" tabindex="-1"><a class="header-anchor" href="#_1-索引的数据结构" aria-hidden="true">#</a> 1. 索引的数据结构</h2><h3 id="_1-1-二叉树" tabindex="-1"><a class="header-anchor" href="#_1-1-二叉树" aria-hidden="true">#</a> 1.1 二叉树</h3><p><img src="'+s+'" alt="image-20230228222304010"></p><ul><li>问题： <ul><li>树的深度比较深，查询一个索引会有很多的磁盘I/O</li></ul></li></ul><h3 id="_1-2-红黑树" tabindex="-1"><a class="header-anchor" href="#_1-2-红黑树" aria-hidden="true">#</a> 1.2 红黑树</h3><p><img src="'+r+'" alt="image-20230228222823188"></p><ul><li>平衡二叉树</li><li>问题： <ul><li>平衡二叉树会对树进行平衡，但是当数据有100万时，2^20 = 1024 * 1024 ,此时树的高度就达到了20，也就是需要20次磁盘IO</li></ul></li></ul><h3 id="_1-3hash表" tabindex="-1"><a class="header-anchor" href="#_1-3hash表" aria-hidden="true">#</a> 1.3Hash表</h3><p><img src="'+h+'" alt="image-20230228223535975"></p><ul><li>对索引的key进行一次hash计算就可以定位出数据存储的位置</li><li>很多时候Hash索引要比B+ 树索引更高效</li><li>问题 <ul><li>仅能满足 “=”，“IN”，不支持范围查询</li><li>hash冲突问题</li></ul></li></ul><h3 id="_1-4-b树" tabindex="-1"><a class="header-anchor" href="#_1-4-b树" aria-hidden="true">#</a> 1.4 B树</h3><p><img src="'+t+'" alt="image-20230228223136494"></p><ul><li>叶节点具有相同的深度，叶节点的指针为空</li><li>所有的索引元素不重复</li><li>节点中的数据索引从左到右递增排列</li><li>问题： <ul><li>所有节点都会存储数据，这样也会导致树的层高比较高，磁盘I/O还是比较多</li></ul></li></ul><h3 id="_1-5-b-树" tabindex="-1"><a class="header-anchor" href="#_1-5-b-树" aria-hidden="true">#</a> 1.5 B+树</h3><p><img src="'+n+'" alt="image-20230228223415403"></p><ul><li>非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引</li><li>叶子节点包含所有索引字段 <ul><li>叶子节点用指针连接，提高区间访问的性能</li></ul></li></ul><h2 id="_2-存储引擎" tabindex="-1"><a class="header-anchor" href="#_2-存储引擎" aria-hidden="true">#</a> 2.存储引擎</h2><p>存储引擎在表级别生效</p><h3 id="_1-myisam" tabindex="-1"><a class="header-anchor" href="#_1-myisam" aria-hidden="true">#</a> 1. MyISAM</h3><ul><li><p>*.frm : 数据表结构相关的文件</p></li><li><p>*.MYD：存储数据库数据的文件</p></li><li><p>*.MYI：存储索引相关的文件</p></li><li><p>MyISAM索引文件和数据文件是分离的(非聚集)</p><p>​ <img src="'+d+'" alt="image-20230301221639787"></p></li><li></li></ul><h3 id="_2-innodb" tabindex="-1"><a class="header-anchor" href="#_2-innodb" aria-hidden="true">#</a> 2.INNODB</h3><ul><li><p>*.frm:数据表结构相关的文件</p></li><li><p>*.ibd:存储索引和数据的文件</p></li><li><p>InnoDB索引实现(聚集)</p><ul><li>表数据文件本身就是按B+Tree组织的一个索引结构文件</li><li>聚集索引-叶子节点包含了完整的数据记录（一般主键的叶子节点是包含了完整的数据记录，是聚集索引）</li><li>为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？ <ul><li>数据使用B+树来存，建主键可以直接把主键当做聚集索引</li><li>如果不建主键，Mysql自己会生成一个row_id生成聚集索引，一方面增加了Mysql的开销，一方面聚集索引对程序不可见不太友好</li><li>整型：相对而言比较节省空间</li><li>自增：自增减少树的平衡开销</li></ul></li><li>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</li></ul></li><li></li></ul>',23),u=[o];function c(p,g){return l(),a("div",null,u)}const b=i(_,[["render",c],["__file","Mysql索引底层结构.html.vue"]]);export{b as default};
